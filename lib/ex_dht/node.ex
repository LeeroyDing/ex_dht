defmodule ExDHT.Node do
  use GenServer
  require Logger
  alias ExDHT.Socket
  alias ExDHT.Utils

  defstruct id: "", host: "", port: 0, trans: %{}, tokens: %{}, local_tokens: %{}, access_time: :os.system_time

  ## Public interface

  @spec start_link(String.t, integer, bitstring()) :: GenServer.on_start
  def start_link(host, port, id) do
    GenServer.start_link __MODULE__, {host, port, id}
  end

  @doc "Get node id"
  @spec id(pid()) :: bitstring()
  def id(node) do
    GenServer.call node, :id
  end

  @doc "Generate and add new transaction"
  @spec add_trans(pid(), String.t, bitstring() | nil) :: bitstring()
  def add_trans(node, name, info_hash \\ nil) do
    GenServer.call node, {:add_trans, name, info_hash}
  end

  @doc "Delete specified transaction"
  @spec delete_trans(pid(), bitstring()) :: :ok | :error
  def delete_trans(node, trans_id) do
    GenServer.call node, {:delete_trans, trans_id}
  end

  @doc "Adds a token for a given info hash as generated by this node"
  @spec add_token(pid(), bitstring(), bitstring()) :: :ok | :error
  def add_token(node, info_hash, token) do
    GenServer.call node, {:add_token, info_hash, token}
  end

  @doc "Returns token for the info hash, if known"
  @spec get_token(pid(), bitstring()) :: bitstring() | nil
  def get_token(node, info_hash) do
    GenServer.call node, {:get_token, info_hash}
  end

  @doc "Delete specified info hash's token"
  @spec delete_token(pid(), bitstring()) :: :ok | :error
  def delete_token(node, info_hash) do
    GenServer.call node, {:delete_token, info_hash}
  end

  @doc "Adds a locally created token for a given info hash for this node"
  @spec add_local_token(pid(), bitstring(), bitstring()) :: :ok | :error
  def add_local_token(node, info_hash, token) do
    GenServer.call node, {:add_local_token, info_hash, token}
  end

  @doc "Returns locally created token for the info hash, if known"
  @spec get_local_token(pid(), bitstring()) :: bitstring() | nil
  def get_local_token(node, info_hash) do
    GenServer.call node, {:get_local_token, info_hash}
  end

  @doc "Delete specified info hash's locally created token"
  @spec delete_local_token(pid(), bitstring()) :: :ok | :error
  def delete_local_token(node, info_hash) do
    GenServer.call node, {:delete_local_token, info_hash}
  end

  @doc "Update last access/modify time of this node"
  @spec update_access(pid(), integer) :: :ok | :error
  def update_access(node, system_time \\ nil) do
    system_time = case system_time do
                    nil -> :os.system_time
                    x -> x
                  end
    GenServer.call node, {:update_access, system_time}
  end

  ## Sending messages
  
  def send_protocol_error(node, message, trans_id \\ nil) do
    GenServer.call node, {:send_protocol_error, message, trans_id}
  end

  def ping(node, sender_id \\ nil) do
    GenServer.call node, {:ping, sender_id}
  end

  def pong(node, trans_id \\ nil, sender_id \\ nil) do
    GenServer.call node, {:pong, trans_id, sender_id}
  end

  def find_node(node, target_id, sender_id \\ nil) do
    GenServer.call node, {:find_node, target_id, sender_id}
  end

  def found_node(node, found_nodes, trans_id \\ nil, sender_id \\ nil) do
    GenServer.call node, {:fond_node, found_nodes, trans_id, sender_id}
  end

  def get_peers(node, info_hash, sender_id \\ nil) do
    GenServer.call node, {:get_peers, info_hash, sender_id}
  end

  def got_peers(node, token, values, nodes, trans_id \\ nil, sender_id \\ nil) do
    GenServer.call node, {:got_peers, token, values, nodes, trans_id, sender_id}
  end

  def announce_peer(node, token, info_hash, sender_id \\ nil) do
    GenServer.call node, {:announce_peer, token, info_hash, sender_id}
  end

  ## Server callback

  def init({host, port, id}) do
    {:ok, %__MODULE__{host: host, port: port, id: id}}
  end

  def handle_call(:id, _from, state) do
    {:reply, state.id, state}
  end
  
  def handle_call({:add_trans, name, info_hash}, _from, state) do
    {trans_id, state} = do_add_trans(state, name, info_hash)
    {:reply, trans_id, state}
  end

  def handle_call({:delete_trans, trans_id}, _from, state) do
    trans = Map.delete(state.trans, trans_id)
    {:reply, :ok, %{state | trans: trans}}
  end

  def handle_call({:add_token, info_hash, token}, _from, state) do
    tokens = Map.put_new(state.tokens, info_hash, token)
    {:reply, :ok, %{state | tokens: tokens}}
  end

  def handle_call({:get_token, info_hash}, _from, state) do
    {:reply, Map.get(state.tokens, info_hash), state}
  end

  def handle_call({:delete_token, info_hash}, _from, state) do
    tokens = Map.delete(state.tokens, info_hash)
    {:reply, :ok, %{state | tokens: tokens}}
  end

  def handle_call({:add_local_token, info_hash, token}, _from, state) do
    local_tokens = Map.put_new(state.local_tokens, info_hash, token)
    {:reply, :ok, %{state | local_tokens: local_tokens}}
  end

  def handle_call({:get_local_token, info_hash}, _from, state) do
    {:reply, Map.get(state.local_tokens, info_hash), state}
  end

  def handle_call({:delete_local_token, info_hash}, _from, state) do
    local_tokens = Map.delete(state.local_tokens, info_hash)
    {:reply, :ok, %{state | local_tokens: local_tokens}}
  end

  def handle_call({:send_protocol_error, message, trans_id}, _from, state) do
    message = %{
      "y" => "e",
      "e" => [203, message]
    }
    Logger.debug "protocol error msg to #{state.host}:#{state.port}"
    {:reply, send_message(state, message, trans_id), state}
  end

  def handle_call({:ping, sender_id}, _from, state) do
    {trans_id, state} = do_add_trans(state, "ping")
    message = %{
      "y" => "q",
      "q" => "ping",
      "a" => %{
        "id" => sender_id
      }
    }
    Logger.debug "ping msg to #{state.host}:#{state.port}"
    {:reply, send_message(state, message, trans_id), state}
  end

  def handle_call({:find_node, target_id, sender_id}, _from, state) do
    {trans_id, state} = do_add_trans(state, "find_node")
    message = %{
      "y" => "q",
      "q" => "find_node",
      "a" => %{
        "id" => sender_id,
        "target" => target_id
      }
    }
    Logger.debug "find_node msg to #{state.host}:#{state.port}"
    {:reply, send_message(state, message, trans_id), state}
  end

  ## Private functions

  defp do_add_trans(state, name, info_hash \\ nil) do
    trans_id = Utils.random_trans_id
    trans = Map.put(
      state.trans, trans_id, %{
        "name" => name,
        "info_hash" => info_hash,
        "access_time" => :os.system_time
      }
    )
    {trans_id, %{state | trans: trans}}
  end

  @spec send_message(%__MODULE__{}, map(), bitstring() | nil) :: :ok | :error
  defp send_message(state, message, trans_id \\ nil) do
    message = Map.put_new(message, "v", Utils.version)
    message = case trans_id do
                nil -> message
                t -> Map.put_new(message, "t", t)
              end
    IO.inspect(message, limit: 10000)
    encoded = Bencode.encode!(message)
    File.write!("/Users/leeroy/encoded", encoded)
    Socket.send_message(encoded, state.host, state.port)
  end
  
end
